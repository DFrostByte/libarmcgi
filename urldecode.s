@ tabstop=4

	.arch armv6

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	.section .text
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	.align	2

@--------------------------------------------------------------------------
	.global	url_decode
	.type	url_decode, %function
@--------------------------------------------------------------------------
@ char *url_decode(char *url);
@
@ Takes address of null-terminated string in r0. Replaces '+' with ' ' and
@ decodes pairs of hex characters preceded by '%'. If either hex character is
@ null (end of string) or not a hex character, the '%' will be copied before
@ continuing to loop through the string from the character following '%'.
@
@ Updates (if any) are made in place to the original string.
@
@ Returns address originally provided in r0.
@--------------------------------------------------------------------------
url_decode:
	movs	r1, r0			@ copy str address for updating
	bxeq	lr				@ return NULL pointer

	@ save str address for return and registers used during hex decoding
	push	{r0,r4-r6}

	ldr	    r6, =ascii_hex_val_table

1: @LOOP
	ldrb	r2, [r0], #1	@ load str byte and increment pointer

	@---------------------
	@ replace '+' with ' '
	@---------------------
	cmp		r2, #'+
	moveq	r2, #0x20
	beq		2f				@CONTINUE
	@---------------------

	@---------------------
	@ if char is '%' replace with value of the two following hex chars.
	@---------------------
	cmp		r2, #'%
	bne		2f				@CONTINUE

	ldrb	r4, [r0]		@ fetch high nibble byte
	tst   	r4, r4			@ is it null?
	ldrneb	r5, [r0, #1]	@ no, fetch low nibble byte
	tstne	r5, r5			@ is it null?
	beq		2f				@CONTINUE if either byte was null

	ldrb	r4, [r6, r4]	@ load first byte value from hex lookup table
	ldrb	r5, [r6, r5]	@ then the second

	@ invalid hex chars result in 0xFF
	cmp		r4, #0xFF
	cmpne	r5, #0xFF
	beq		2f				@CONTINUE

	@ alter value in r2 to the byte value represented by the hex characters.
	mov		r2, r4, lsl #4	@ set high nibble
	orr		r2, r2, r5		@ set low nibble
	add		r0, #2			@ increase pointer beyond converted hex chars
	@---------------------

2: @CONTINUE
	strb	r2, [r1], #1	@ save byte using the update pointer
	tst		r2, r2			@ null byte - end of string?
	bne		1b				@LOOP

	@LOOP_END

	pop		{r0,r4-r6}		@ restore original str and used registers
	bx		lr


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	.section .rodata
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	.align	2
	.global ascii_hex_val_table
@--------------------------------------------------------------------------
@ char ascii_hex_val_table[256];
@
@ An ascii char value can be used as an index to lookup its corresponding
@ hex value.
@--------------------------------------------------------------------------
ascii_hex_val_table:
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0x00, 0X01, 0X02, 0X03,		0X04, 0X05, 0X06, 0X07
	.byte	0X08, 0X09, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0X0A, 0X0B, 0X0C,		0X0D, 0X0E, 0X0F, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0X0A, 0X0B, 0X0C,		0X0D, 0X0E, 0X0F, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF
	.byte	0xFF, 0xFF, 0xFF, 0xFF,		0xFF, 0xFF, 0xFF, 0xFF

